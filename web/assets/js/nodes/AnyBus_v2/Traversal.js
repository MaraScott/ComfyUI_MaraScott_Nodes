const n=0,l=1,t=["Reroute (rgthree)"],u=["SetNode","GetNode"],o="MaraScottAnyBus_v2";function i(n,l){var t,u,o;const i=null==n?void 0:n.links;return i?i.get&&i.values?null!=(t=i.get(l))?t:null:Array.isArray(i)?null!=(u=i.find(n=>n&&n.id===l))?u:null:null!=(o=i[l])?o:null:null}function e(){var n,l,t;return null!=(t=null!=(l=null==(n=globalThis.app)?void 0:n.graph)?l:globalThis.graph)?t:null}function r(){try{window.dispatchEvent(new CustomEvent("marascott:anybus:changed"))}catch{}}function s(n){var l;const t=null==(l=n.inputs)?void 0:l[0];if(!t||null==t.link)return null;const u=i(n.graph,t.link);return u?n.graph.getNodeById(u.origin_id):null}function d(n){var l,t;const u=null==(l=n.outputs)?void 0:l[0],e=[];if(!(null==(t=null==u?void 0:u.links)?void 0:t.length))return e;for(const r of u.links){const l=i(n.graph,r);if(!l)continue;const t=n.graph.getNodeById(l.target_id);(null==t?void 0:t.type)===o&&e.push(t)}return e}function c(n){var l,t,u,o,i,e;const r=null!=(null==(t=null==(l=n.inputs)?void 0:l[0])?void 0:t.link),s=(null!=(e=null==(i=null==(o=null==(u=n.outputs)?void 0:u[0])?void 0:o.links)?void 0:i.length)?e:0)>0;return!(!r&&!s)}function f(n){const l=new Set,t=[n],u=[];for(;t.length;){const n=t.shift();if(!n||l.has(n.id))continue;l.add(n.id),u.push(n);const i=s(n);(null==i?void 0:i.type)===o&&t.push(i);for(const l of d(n))t.push(l)}return u}function a(n){if(!c(n))return null;const l=f(n);return l.length>1?l:null}function h(n){const l=new Map(n.map(n=>[n.id,n])),t=n.filter(n=>!s(n)),u=[];function o(n,t){const i=d(n);if(i.length&&!i.every(n=>!l.has(n.id)))for(const u of i)l.has(u.id)&&(t.includes(u.id)||o(u,[...t,n.id]));else u.push([...t,n.id])}if(t.length)for(const i of t)o(i,[]);else for(const i of n)o(i,[]);return u.map(n=>n.map(n=>l.get(n)))}function p(n,l,t){var u,i,e;const r=(null!=(u=null==n?void 0:n._nodes)?u:[]).filter(n=>(null==n?void 0:n.type)===o),s=new Map;for(const o of r){const n=null!=(e=null==(i=null==o?void 0:o.properties)?void 0:i[l])?e:t;s.has(n)||s.set(n,[]),s.get(n).push(o)}return s}function v(n,l){return d(n).filter(n=>l.has(n.id))}function g(n,l){const t=s(n);return t&&l.has(t.id)?t:null}function y(n){if(!n.length)return[];const l=new Set(n.map(n=>n.id)),t=n.filter(n=>!g(n,l)),u=[];function o(n,t){const i=v(n,l);if(i.length)for(const l of i)t.includes(l)?u.push([...t,n]):o(l,[...t,n]);else u.push([...t,n])}return t.length?t.forEach(n=>o(n,[])):o(n[0],[]),u}function k(n){var l,t;const u=[],o=null!=(t=null==(l=n.inputs)?void 0:l.length)?t:0;for(let i=1;i<o;i++){const l=n.inputs[i];l&&u.push({slot:i,name:l.name,type:l.type,linked:null!=l.link})}return u}function m(n,l,t){var u,o,e;const r=null==(o=null==(u=null==t?void 0:t.inputs)?void 0:u[0])?void 0:o.link,s=null!=r?i(n,r):null;return s&&s.origin_id===l.id&&0===s.origin_slot?{id:s.id,valid:!0}:{id:null!=(e=null==s?void 0:s.id)?e:null,valid:!1}}export{u as ALLOWED_GETSET,t as ALLOWED_REROUTE,o as ANYBUS_TYPE,n as BUS_SLOT,l as FIRST_INDEX,m as busEdgeInfo,y as chainsForProfile,p as collectAnyBusByProfile,e as getActiveGraph,f as getBusGroup,d as getBusNext,h as getBusPaths,s as getBusPrev,a as getConnectedGroupOrNull,i as getGraphLinkById,c as hasBusLink,v as nextWithinProfile,r as notifyAnyBusChange,g as prevWithinProfile,k as summarizeSlots};
